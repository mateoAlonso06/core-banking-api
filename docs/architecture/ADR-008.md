# ADR-008: Refresh Token Migration to HttpOnly Cookies + CSRF Protection

## Status
Accepted

## Context

ADR-007 introduced refresh tokens sent and received in the JSON request/response body. This required the frontend to store the refresh token in `localStorage` or `sessionStorage`, exposing it to **XSS attacks**: any injected script could read the token and use it to obtain new access tokens for the full 7-day refresh token lifetime.

**Threat model:**

| Attack | Risk with body-based RT | Risk with HttpOnly cookie RT |
|--------|------------------------|------------------------------|
| XSS (script reads token) | High - script reads `localStorage` and exfiltrates RT | Mitigated - `HttpOnly` flag prevents JavaScript access |
| CSRF (forged request from another origin) | Low - attacker cannot construct JSON body cross-origin | Medium - cookie sent automatically, requires CSRF protection |

Moving the refresh token to an HttpOnly cookie eliminates the XSS vector but introduces CSRF risk. The **Double Submit Cookie** pattern is used to mitigate CSRF.

## Decision

### 1. Refresh Token in HttpOnly Cookie

On successful login (and token refresh), the server sets the refresh token as an HttpOnly cookie instead of including it in the JSON response body:

```
Set-Cookie: refresh_token=<token>; HttpOnly; Secure; SameSite=Lax; Path=/api/v1/auth; Max-Age=604800
```

| Attribute | Value | Rationale |
|-----------|-------|-----------|
| `HttpOnly` | `true` | JavaScript cannot read the cookie |
| `Secure` | configurable (`cookie.secure`) | `true` in production (HTTPS only), `false` for local dev (HTTP) |
| `SameSite` | `Lax` | Cookie sent on same-site requests and top-level navigations; blocks most CSRF |
| `Path` | `/api/v1/auth` | Cookie only sent to auth endpoints, not to the entire API |
| `Max-Age` | 604800 (7 days) | Matches refresh token lifetime |

The `LoginResult` record's `refreshToken` field is annotated with `@JsonIgnore` so it is excluded from JSON serialization while remaining accessible internally for cookie creation.

### 2. CSRF Protection — Double Submit Cookie Pattern

Since cookies are sent automatically by the browser, mutating requests that rely on the refresh token cookie must be protected against CSRF:

1. On login and token refresh, the server sets a **non-HttpOnly** cookie `XSRF-TOKEN` with a cryptographically random value (32 bytes, Base64URL-encoded)
2. The frontend reads this cookie (JavaScript can read it because it is not HttpOnly) and sends its value as the `X-XSRF-TOKEN` header on mutating requests
3. A custom `CsrfTokenFilter` validates that the header matches the cookie
4. An attacker's cross-origin request causes the browser to send the cookie automatically, but the attacker cannot read the cookie value (Same-Origin Policy) to set the header

**CSRF enforcement scope:**
- Only enforced on requests that carry the `refresh_token` cookie (i.e., `/refresh`, `/logout`)
- Safe methods (GET, HEAD, OPTIONS) are always skipped
- Requests without the `refresh_token` cookie are skipped (no cookie-based session to protect)

Spring Security's built-in CSRF remains disabled — the custom filter provides targeted protection only where cookie-based credentials are used.

### 3. Endpoint Changes

| Endpoint | Before | After |
|----------|--------|-------|
| `POST /login` | Returns `refreshToken` in JSON body | Sets `refresh_token` cookie + `XSRF-TOKEN` cookie; `refreshToken` excluded from JSON |
| `POST /2fa/verify` | Returns `refreshToken` in JSON body | Same as login |
| `POST /refresh` | Receives `refreshToken` in JSON body (`RefreshTokenRequest`) | Reads `refresh_token` cookie; requires `X-XSRF-TOKEN` header |
| `POST /logout` | Receives `refreshToken` in JSON body (`RefreshTokenRequest`) | Reads `refresh_token` cookie; clears both cookies; requires `X-XSRF-TOKEN` header |

### 4. Removed Artifacts

`RefreshTokenRequest` DTO is deleted — the refresh token is no longer sent in the request body.

## Implementation Files

```
New:
├── auth/infraestructure/config/CookieHelper.java                    # Cookie creation/extraction utility
└── auth/infraestructure/adapter/out/filter/CsrfTokenFilter.java     # Double Submit Cookie validation

Modified:
├── auth/application/dto/result/LoginResult.java                     # @JsonIgnore on refreshToken
├── auth/infraestructure/adapter/in/rest/AuthRestController.java     # Cookie-based refresh/logout
├── auth/infraestructure/config/SecurityConfig.java                  # Register CsrfTokenFilter, CORS header
└── application.yml                                                  # cookie.secure property

Deleted:
└── auth/infraestructure/adapter/in/rest/dto/request/RefreshTokenRequest.java
```

**No changes:** Domain layer, application services, JWT filter, refresh token model, ports, repositories.

## Consequences

### Positive

1. **XSS-resistant refresh tokens:** `HttpOnly` flag prevents JavaScript from accessing the token
2. **CSRF protection:** Double Submit Cookie pattern prevents cross-origin abuse of the cookie
3. **No domain/application layer changes:** All changes confined to infrastructure layer
4. **Browser-managed lifecycle:** Cookies are automatically sent and expire without frontend code

### Negative

1. **Cookie size on auth requests:** Every request to `/api/v1/auth/*` includes the cookie header (~60 bytes, negligible)
2. **Frontend must read `XSRF-TOKEN` cookie:** Adds a small requirement for the frontend to extract the cookie value and send it as a header
3. **Local development requires `cookie.secure=false`:** HTTPS is not typically used in local dev; the `Secure` flag must be disabled

### Mitigations

| Concern | Mitigation |
|---------|------------|
| CSRF on non-auth endpoints | Cookie `Path=/api/v1/auth` ensures it is not sent to other API paths |
| Cookie theft via network sniffing | `Secure` flag in production ensures HTTPS-only transmission |
| `SameSite=Lax` limitations | Double Submit Cookie provides defense-in-depth beyond SameSite |

## References

- [OWASP Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
- [RFC 6265bis — Cookies: HTTP State Management Mechanism](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis)
