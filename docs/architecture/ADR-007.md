# ADR-007: Refresh Token Strategy, Session Management, and Logout

## Status
Accepted

## Context

The initial JWT implementation issued a single long-lived access token (24 hours) with no logout mechanism and no server-side session control. This created several security gaps:

| Gap | Risk |
|-----|------|
| No logout endpoint | Tokens remained valid until natural expiration; users had no way to end a session |
| Long-lived access tokens (24h) | A stolen token granted 24 hours of unauthorized access with no revocation path |
| No session control | A user could accumulate multiple simultaneous active sessions from different tabs or devices |
| No token revocation | Compromised tokens could not be invalidated |

**Requirements:**
1. Allow users to explicitly terminate their session (logout)
2. Limit the damage window of a stolen access token
3. Maintain seamless UX without frequent re-authentication
4. Prevent concurrent duplicate sessions from the same user
5. Keep the database from growing unbounded with stale token records

## Decision

### 1. Dual-Token Architecture

Two tokens are issued on every successful login:

| Token | Lifetime | Storage | Stateless? | Purpose |
|-------|----------|---------|------------|---------|
| Access Token (JWT) | 5 minutes | Client only | Yes | Authenticates API requests |
| Refresh Token | 7 days | Client + Database | No | Obtains new access tokens |

**Access token** remains stateless (no server-side storage). Its short lifetime (5 minutes) limits the damage window of a stolen token to an acceptable range without requiring a blacklist mechanism.

**Refresh token** is persisted in the `refresh_tokens` table. Persistence is the foundation for all session control features: revocation, rotation, and cleanup.

```
Login → { accessToken (JWT, 5min), refreshToken (UUID, 7 days, stored in DB) }

AT expires → POST /auth/refresh { refreshToken } → { new AT, new RT }

Logout     → POST /auth/logout  { refreshToken } → RT revoked in DB
```

### 2. Refresh Token Generation

Refresh tokens are generated as `UUID.randomUUID().toString()` — a 128-bit cryptographically random value. This provides sufficient entropy (2^122 possible values after UUID version bits) to make brute-force enumeration computationally infeasible.

No JWT structure is used for refresh tokens because:
- They do not need to carry claims (the server validates by DB lookup)
- A simple opaque string is harder to misuse if intercepted
- Revocation is the primary mechanism, not signature verification

### 3. Refresh Token Rotation

Every time a refresh token is used at `POST /auth/refresh`, the old token is revoked and a brand-new one is issued alongside the new access token:

```
Client sends RT1 → server validates RT1
                 → RT1.revoked = true (save)
                 → new AT2 + RT2 issued
                 → RT1 in DB: revoked, RT2 in DB: active
```

**Why rotate:**  If RT1 is stolen and the attacker uses it after the legitimate user already did, RT1 is already revoked and the attacker gets a 401. Without rotation, a stolen RT would be valid for its full 7-day lifetime.

### 4. Single-Session Policy

On every successful login (including 2FA verification), all existing refresh tokens for that user are revoked before the new one is issued:

```java
refreshTokenRepository.revokeAllByUserId(user.getId()); // revoke all prior sessions
RefreshToken newToken = RefreshToken.createNew(user.getId()); // issue new session
```

**Effect:** A user cannot have parallel active sessions. A new login from Tab 2 invalidates the session from Tab 1. Tab 1's refresh token becomes revoked; Tab 1 will receive a 401 on its next refresh attempt and must re-authenticate.

**Accepted tradeoff:** Tab 1's access token (already issued, stateless) remains valid for up to 5 minutes after the session is revoked. This window is accepted as a reasonable tradeoff against the complexity of maintaining an access token blacklist. Reducing the AT lifetime to 5 minutes (from the original 24 hours) minimizes this window to an operationally acceptable level.

### 5. Logout Design

`POST /auth/logout` accepts the refresh token in the request body and revokes it:

**Authentication requirement:** The logout endpoint is public (no access token required). The refresh token itself serves as the credential — possession of the RT proves ownership of that session. Requiring a valid AT for logout would create a deadlock when the AT has already expired.

**Idempotency:** Logout is designed to always succeed (return 204) regardless of the token's current state:

```
Token not found (cleaned up by job) → no-op        → 204
Token valid                         → revoke + save → 204
Token expired (job not yet run)     → revoke + save → 204
Token already revoked               → no-op (guard) → 204
```

The guard `if (!refreshToken.isRevoked())` prevents an unnecessary `UPDATE` when the token is already revoked, avoiding a pointless database write.

### 6. Nightly Cleanup Job

Revoked and expired tokens accumulate in the `refresh_tokens` table over time. A scheduled job purges them nightly:

```java
@Scheduled(cron = "0 0 3 * * *") // 03:00 AM daily
public void purgeExpiredAndRevokedTokens() { ... }
```

**JPQL query:**
```sql
DELETE FROM refresh_tokens WHERE expires_at < NOW() OR revoked = true
```

**Why 3:00 AM:** Low-traffic window minimizes contention with active user sessions.

`@EnableScheduling` is declared on `CoreBankingSystemApplication` (the application entry point) because scheduling is a global application-level concern, not specific to any module configuration.

### 7. Access Token Lifetime Configuration

The access token lifetime is externalized to the environment:

```
JWT_EXPIRATION_MS=300000   # 5 minutes (production)
```

This allows the lifetime to be tuned per environment without code changes. The JWT secret is generated using `openssl rand -base64 32`, producing 256 bits of entropy via the OS CSPRNG (`/dev/urandom`).

## Implementation Files

```
Domain:
├── auth/domain/model/RefreshToken.java                          # Domain model
├── auth/domain/port/out/RefreshTokenRepositoryPort.java         # Outbound port
└── auth/domain/exception/InvalidRefreshTokenException.java      # Domain exception

Application:
├── auth/application/usecase/RefreshTokenUseCase.java            # Inbound port
├── auth/application/usecase/LogoutUseCase.java                  # Inbound port
├── auth/application/dto/result/LoginResult.java                 # Updated: +refreshToken field
├── auth/application/service/AuthService.java                    # login, refresh, logout
└── auth/application/service/TwoFactorService.java               # Updated: emits refresh token

Infrastructure:
├── auth/infraestructure/adapter/out/persistence/entity/
│   └── RefreshTokenJpaEntity.java
├── auth/infraestructure/adapter/out/persistence/repository/
│   ├── SpringRefreshTokenJpaRepository.java                     # @Modifying JPQL queries
│   └── RefreshTokenRepositoryAdapter.java
├── auth/infraestructure/adapter/out/mapper/
│   └── RefreshTokenJpaMapper.java
├── auth/infraestructure/adapter/in/rest/
│   └── AuthRestController.java                                  # POST /refresh, POST /logout
├── auth/infraestructure/adapter/in/rest/dto/request/
│   └── RefreshTokenRequest.java
├── auth/infraestructure/config/
│   └── SecurityConstants.java                                   # /refresh, /logout as public
└── auth/infraestructure/job/
    └── RefreshTokenCleanupJob.java                              # Nightly purge
```

## Consequences

### Positive

1. **True logout:** Sessions can be explicitly terminated server-side
2. **Stolen token mitigation:** RT rotation limits reuse to a single window; short AT lifetime caps the damage to 5 minutes
3. **Session uniqueness:** Single-session policy prevents duplicate concurrent sessions
4. **Controlled table growth:** Nightly cleanup keeps `refresh_tokens` table bounded
5. **Idempotent logout:** Client can safely retry logout without errors
6. **No infrastructure addition:** Refresh tokens persist in the existing PostgreSQL database; no Redis dependency added for this feature

### Negative

1. **AT revocation gap:** Up to 5 minutes where a revoked session's access token remains technically valid (accepted tradeoff)
2. **DB lookup on refresh:** Every token refresh requires a database read and two writes (revoke old, insert new)
3. **Single-session limitation:** Users cannot be logged in from multiple devices simultaneously under the current policy

### Mitigations

| Concern | Mitigation |
|---------|------------|
| AT revocation gap | 5-minute AT lifetime reduces the window to operationally acceptable levels |
| Single-session UX | Policy can be relaxed to multi-device in the future by adding a `device_id` column to `refresh_tokens` and scoping revocation per device |
| Cleanup job reliability | Job logs deleted count; can be extended with alerting if count exceeds a threshold |

## Alternatives Considered

**Access token blacklist (Redis):** Would close the 5-minute AT revocation gap by storing invalidated JWT IDs in Redis with TTL. Rejected because Redis is already used for rate limiting and adding token blacklisting would couple the authentication flow to Redis availability. The 5-minute window was deemed acceptable.

**Token version per user:** Storing a `token_version` claim in the JWT and incrementing it on new login would instantly invalidate all prior ATs. Rejected for the same reasons — requires a cache/DB hit on every authenticated request, adding latency to the hot path.

**Multi-device sessions:** Allowing one active refresh token per device instead of one globally. Not implemented to keep the initial design simple. The `RefreshTokenRepositoryPort` interface is designed to accommodate this future extension via `revokeAllByUserId` being replaceable with a `revokeByUserIdAndDevice` variant.

## References

- [OAuth 2.0 Security Best Current Practice — RFC 9700](https://datatracker.ietf.org/doc/html/rfc9700)
- [OAuth 2.0 for Browser-Based Apps — RFC 9449](https://datatracker.ietf.org/doc/html/rfc9449)
- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
- [OWASP JSON Web Token Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)