# ADR-005: JWT-based Authentication and Authorization System with Roles and Permissions

## Status
Accepted

## Context
The banking system requires a robust authentication and authorization mechanism that:
- Supports multiple roles with different access levels
- Allows fine-grained permissions per operation
- Is stateless for horizontal scalability
- Maintains compatibility with hexagonal architecture

The initial implementation used a simple enum `Role` (CUSTOMER, ADMIN, BRANCH_MANAGER) stored as VARCHAR, without granular permissions.

## Decision

### 1. Data Model: Roles and Permissions in the Database

A relational model with three tables was implemented:

```
permissions (id, code, description, module)
roles (id, name, description)
role_permissions (role_id, permission_id)  -- N:M
users.role_id -> roles(id)                 -- FK
```

**Defined Roles:**
| Role | Description |
|------|-------------|
| CUSTOMER | Bank customer with basic operations |
| SUPPORT | Customer support, read-only access |
| BRANCH_MANAGER | Branch manager, account control |
| COMPLIANCE | Compliance officer, KYC management |
| AUDITOR | Internal auditor, full read + export |
| ADMIN | Administrator with full access |

**Permissions per module:**

| Module | Permissions |
|--------|------------|
| CUSTOMER | CUSTOMER_VIEW_OWN, CUSTOMER_VIEW, CUSTOMER_VIEW_ALL, KYC_APPROVE, KYC_REJECT |
| ACCOUNT | ACCOUNT_CREATE, ACCOUNT_VIEW_OWN, ACCOUNT_VIEW, ACCOUNT_VIEW_ALL, ACCOUNT_BLOCK, ACCOUNT_CLOSE |
| TRANSACTION | TRANSACTION_DEPOSIT, TRANSACTION_WITHDRAW, TRANSACTION_TRANSFER, TRANSACTION_VIEW_OWN, TRANSACTION_VIEW, TRANSACTION_VIEW_ALL, TRANSACTION_REVERSE |
| AUDIT | AUDIT_VIEW, AUDIT_EXPORT |
| USER | USER_VIEW, USER_BLOCK, USER_CHANGE_ROLE |

**Assignment matrix:**

| Permission | CUSTOMER | SUPPORT | BRANCH_MGR | COMPLIANCE | AUDITOR | ADMIN |
|------------|:--------:|:-------:|:----------:|:----------:|:-------:|:-----:|
| CUSTOMER_VIEW_OWN | X | | | | | X |
| CUSTOMER_VIEW | | X | X | X | X | X |
| CUSTOMER_VIEW_ALL | | X | X | X | X | X |
| KYC_APPROVE | | | | X | | X |
| KYC_REJECT | | | | X | | X |
| ACCOUNT_CREATE | X | | | | | X |
| ACCOUNT_VIEW_OWN | X | | | | | X |
| ACCOUNT_VIEW | | X | X | X | X | X |
| ACCOUNT_VIEW_ALL | | X | X | | X | X |
| ACCOUNT_BLOCK | | | X | | | X |
| ACCOUNT_CLOSE | | | X | | | X |
| TRANSACTION_DEPOSIT | X | | | | | X |
| TRANSACTION_WITHDRAW | X | | | | | X |
| TRANSACTION_TRANSFER | X | | | | | X |
| TRANSACTION_VIEW_OWN | X | | | | | X |
| TRANSACTION_VIEW | | X | X | X | X | X |
| TRANSACTION_VIEW_ALL | | | X | X | X | X |
| TRANSACTION_REVERSE | | | X | | | X |
| AUDIT_VIEW | | | | X | X | X |
| AUDIT_EXPORT | | | | | X | X |
| USER_VIEW | | | X | | | X |
| USER_BLOCK | | | | | | X |
| USER_CHANGE_ROLE | | | | | | X |

### 2. Authentication: Stateless JWT

**Token structure:**
```json
{
  "sub": "user-uuid",
  "email": "user@example.com",
  "role": "CUSTOMER",
  "permissions": ["CUSTOMER_VIEW_OWN", "ACCOUNT_CREATE", "..."],
  "iat": 1706284800,
  "exp": 1706288400
}
```

**Authentication flow:**
```
1. POST /api/v1/auth/login {email, password}
2. Validate credentials against DB
3. Load Role with its Permissions
4. Generate JWT with claims: sub, email, role, permissions[]
5. Return token to client
```

**Authorization flow per request:**
```
1. Request with header: Authorization: Bearer <token>
2. JwtAuthenticationFilter extracts and validates token
3. Extracts role and permissions from JWT
4. Creates GrantedAuthority for role (ROLE_X) and each permission
5. SecurityContext stores Authentication
6. @PreAuthorize("hasAuthority('PERMISSION')") validates access
```

### 3. Authorization in Controllers

Migrated from `hasRole()` to `hasAuthority()`:

```java
// Before
@PreAuthorize("hasRole('ADMIN')")

// After
@PreAuthorize("hasAuthority('KYC_APPROVE')")
@PreAuthorize("hasAnyAuthority('ACCOUNT_VIEW_OWN', 'ACCOUNT_VIEW')")
```

### 4. Hexagonal Architecture

```
auth/
├── domain/
│   ├── model/
│   │   ├── Permission.java      # Domain entity
│   │   ├── Role.java            # Entity with Set<Permission>
│   │   ├── RoleName.java        # Enum identifier
│   │   └── User.java            # Aggregate with Role
│   └── port/out/
│       ├── RoleRepositoryPort.java
│       └── TokenGenerator.java  # Interface with permissions
└── infraestructure/
    └── adapter/out/
        ├── persistence/
        │   ├── entity/
        │   │   ├── RoleJpaEntity.java      # @ManyToMany permissions
        │   │   └── PermissionJpaEntity.java
        │   └── repository/
        │       └── RoleRepositoryAdapter.java
        └── security/
            ├── JwtTokenProvider.java       # Generates JWT with permissions
            └── JwtAuthenticationFilter.java # Extracts authorities
```

## Consequences

### Positive
- Fine-grained: control per operation, not just by role
- Extensible: new permissions without code changes
- Auditable: explicit permissions in JWT and DB
- Stateless: no server session required
- Separation of concerns: domain decoupled from Spring Security
- Compatibility: hasRole() still works (ROLE_X authority)

### Negative
- Larger JWT: includes array of permissions (mitigated with short codes)
- Permission changes require re-login: token is not invalidated automatically
- Initial complexity: more tables and mappings
- Cache needed: consider role cache for high traffic

## Future Work

### Refresh Tokens (Pending)

To improve user experience and security, the following is planned:

```
refresh_tokens (id, user_id, token, expires_at, revoked, created_at)
```

**Proposed flow:**
```
1. Login returns: { access_token (15min), refresh_token (7 days) }
2. Access token expires
3. POST /api/v1/auth/refresh with refresh_token
4. Validate refresh_token in DB (not revoked, not expired)
5. Generate new access_token
6. Optionally rotate refresh_token
```

**Considerations:**
- Store refresh tokens in DB (stateful) to allow revocation
- Implement revocation on logout and password change
- Consider token rotation to mitigate token theft
- The `refresh_tokens` table already exists in the schema (V1)

### Token Invalidation on Permission Change

When permissions for a role are changed:
- Option A: Invalidate all tokens for users with that role
- Option B: Check permissions against DB on every request (lose statelessness)
- Option C: Short-lived tokens + frequent refresh tokens

## References
- [OWASP JWT Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
- [Spring Security Reference](https://docs.spring.io/spring-security/reference/)
- Migrations: V5, V6, V7 in `src/main/resources/db/migration/`

