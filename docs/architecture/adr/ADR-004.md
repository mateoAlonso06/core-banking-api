# ADR-004: Entity Relationships Between Bounded Contexts

## Status
Accepted

## Context
The system is organized into bounded contexts (Auth, Customer, Account, Transaction, Audit), each representing a cohesive domain area. Entities within these contexts need to reference entities in other contexts (e.g., a Transaction references an Account).

There are two approaches for handling cross-BC relationships:

1. **Foreign Keys at DB level**: Strong referential integrity enforced by the database
2. **UUID references only**: Referential integrity enforced by the application

The initial schema (V1) used FK constraints for all relationships, including cross-BC ones. This creates tight coupling between contexts at the database level.

## Decision
Adopt a **hybrid approach** for entity relationships:

### Within the same Bounded Context
- Use **FK constraints** at DB level
- Use **JPA relationships** (`@ManyToOne`, `@OneToMany`) for navigation
- Database enforces referential integrity

### Between different Bounded Contexts
- Use **UUID columns only** (no FK constraints)
- Use **primitive UUID fields** in JPA entities (no `@ManyToOne`)
- Application enforces referential integrity through validation

### Relationship Matrix

| From BC | To BC | Relationship | FK? | JPA Relation? |
|---------|-------|--------------|-----|---------------|
| Auth | Auth | `refresh_tokens.user_id` → `users` | Yes | Yes |
| Customer | Auth | `customers.user_id` → `users` | No | No |
| Account | Customer | `accounts.customer_id` → `customers` | No | No |
| Account | Account | `account_holds.account_id` → `accounts` | Yes | Yes |
| Transaction | Account | `transactions.account_id` → `accounts` | No | No |
| Transaction | Account | `transfers.source_account_id` → `accounts` | No | No |
| Transaction | Account | `transfers.destination_account_id` → `accounts` | No | No |
| Transaction | Transaction | `transfers.*_transaction_id` → `transactions` | Yes | Yes |
| Audit | Auth | `audit_logs.user_id` → `users` | No | No |

### Application-Level Validation
Cross-BC references must be validated before persistence:

```java
// TransferRepositoryAdapter.java
public Transfer save(Transfer transfer) {
    // Validate referenced entities exist (same transaction context)
    var transactionOut = transactionJpaRepository.findById(transfer.getDebitTransactionId())
        .orElseThrow(() -> new IllegalStateException("Debit transaction not found"));

    // ... proceed with save
}
```

### JPA Entity Pattern

**Within BC (with FK):**
```java
// TransferJpaEntity.java - same BC as TransactionJpaEntity
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "debit_transaction_id", nullable = false)
private TransactionJpaEntity debitTransaction;
```

**Cross-BC (no FK):**
```java
// TransactionJpaEntity.java - references Account BC
@Column(name = "account_id", nullable = false)
private UUID accountId;  // No @ManyToOne, no navigation
```

## Rationale

### Why remove cross-BC foreign keys?

1. **Bounded Context independence**: Each BC can evolve its schema without affecting others

2. **Microservices readiness**: If contexts are extracted to separate services with separate databases, no schema changes are needed

3. **No physical deletes in financial systems**: The primary risk of orphaned data is mitigated because:
   - Accounts are never deleted, only closed (`status = 'CLOSED'`)
   - Customers are never deleted, only deactivated
   - Transactions are immutable (append-only ledger)
   - Users are never deleted, only blocked

4. **Application already validates**: Before creating cross-BC references, the application fetches and validates the referenced entity exists

5. **Aligns with DDD principles**: Aggregates in different BCs communicate through IDs, not direct references

### Why keep intra-BC foreign keys?

1. **Strong consistency within aggregate boundaries**: An Account and its Holds are part of the same aggregate

2. **Cascade operations make sense**: Deleting a User should cascade to their RefreshTokens

3. **JPA navigation is useful**: Loading a Transfer with its Transactions is a common operation within the Transaction BC

## Consequences

### Positive
- Bounded contexts are decoupled at the database level
- Easier migration path to microservices architecture
- Schema changes in one BC don't require changes in others
- Clearer ownership boundaries

### Negative
- No DB-level protection against orphaned cross-BC references
- Requires discipline: always validate before persisting cross-BC references
- Cannot use cascade deletes across BCs (but we don't delete anyway)

### Mitigations
- **No physical deletes**: Use status fields instead (CLOSED, INACTIVE, BLOCKED)
- **Validation in adapters**: Repository adapters validate cross-BC references
- **Indexes preserved**: Query performance maintained with existing indexes

## Migration
See `V2__remove_cross_bc_foreign_keys.sql` for the migration that removes cross-BC FK constraints.

## Related
- ADR-001: Value Objects
- ADR-002: Account Identifiers
- ADR-003: Exception Hierarchy