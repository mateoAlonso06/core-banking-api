# ADR-002: Generación de Identificadores para Cuentas Bancarias

## Status
Accepted

## Context

El sistema bancario requiere generar dos tipos de identificadores únicos para cada cuenta:

### Número de Cuenta (CBU)
El dominio necesita un identificador numérico de cuenta que:

- Sea solo dígitos y de longitud fija para interoperabilidad y validaciones simples
- Permita detectar errores de tipeo o transmisión (checksum/verificador)
- No exponga información sensible (por ejemplo, secuencias incrementales fáciles de enumerar)
- Mantenga la lógica de generación fuera del dominio, delegando a infraestructura mediante un puerto (hexagonal)

### Alias de Cuenta
El sistema requiere un alias de cuenta que:

- Sea humano-legible para compartir y recordar (experiencia de usuario)
- Cumpla un formato validable por el dominio, con restricciones claras (caracteres permitidos y longitud)
- Minimice la predictibilidad (evitar que observar aliases permita inferir próximos aliases)
- El VO `AccountAlias` establece invariantes del formato: solo `[a-z0-9._-]` y longitud entre 6 y 20 caracteres

## Decision

### 1. Generador de Número de Cuenta (AccountNumber)

Se decidió implementar un adaptador de infraestructura `AccountNumberGeneratorAdapter` que genera el número de cuenta combinando:

1. Un prefijo numérico según `AccountType` (`accountType.getNumericCode()`), para codificar el tipo de cuenta
2. Un bloque de 18 dígitos derivados de un `UUID.randomUUID()` (alta entropía, no secuencial)
3. Un verificador de 2 dígitos calculado con un algoritmo tipo Modulo 11 (patrón de pesos) a partir del "baseNumber"

La longitud final queda en **22 dígitos**, validada por el Value Object `AccountNumber`.

**Detalles de implementación:**

- El adaptador construye `baseNumber = typePrefix + uuidDigits`, donde `uuidDigits` se obtiene extrayendo dígitos de la representación hex del UUID y normalizando letras hex (a..f) a números (mod 10)
- Luego calcula `verifier = AccountNumber.calculateVerifierForBase(baseNumber)` y concatena para obtener el número final
- El VO `AccountNumber` asegura invariantes: no nulo, 22 dígitos exactos y solo caracteres numéricos
- El verificador usa pesos `{3, 9, 7, 1}` aplicados cíclicamente y produce un resultado formateado a 2 dígitos

**Ejemplo:**
```
UUID: 550e8400-e29b-41d4-a716-446655440000
Extracción de dígitos: 550484004294147164 (18 dígitos)
Prefijo tipo cuenta: 01 (2 dígitos)
Base: 01550484004294147164 (20 dígitos)
Verificador Módulo 11: 06 (2 dígitos)
Número cuenta final: 0155048400429414716406 (22 dígitos)
```

### 2. Generador de Alias (AccountAlias)

Se decidió implementar un adaptador de infraestructura `AccountAliasGeneratorAdapter` que genera alias pseudo "memorizables" con el formato:

```
{adjective}.{noun}.{3-digits}
```

**Componentes:**

- Listas controladas de `ADJECTIVES` (40 elementos) y `NOUNS` (40 elementos)
- Un número de 3 dígitos (100–999)
- `SecureRandom` como fuente de aleatoriedad criptográficamente más robusta
- Verificación de unicidad en base de datos antes de asignar
- Mecanismo de reintentos (máximo 5 intentos)

**Espacio de combinaciones:** 40 × 40 × 900 = **1,440,000 combinaciones posibles**

**Detalles de implementación:**

- El adaptador selecciona un adjetivo y un sustantivo aleatorios:
  - `ADJECTIVES.get(RANDOM.nextInt(ADJECTIVES.size()))`
  - `NOUNS.get(RANDOM.nextInt(NOUNS.size()))`
- Genera `number = RANDOM.nextInt(900) + 100` para asegurar 3 dígitos
- Construye `aliasValue = String.format("%s.%s.%d", adjective, noun, number)`
- Verifica unicidad consultando `aliasRepository.existsByAlias(aliasValue)`
- Si existe colisión, reintenta hasta `MAX_RETRIES`
- Retorna `new AccountAlias(aliasValue)`

**Ejemplo:**
```
Alias generados: "happy.tree.456", "calm.storm.542", "soft.cloud.189"
```

### 3. Garantía de Unicidad

**Constraints en base de datos:**
```sql
ALTER TABLE bank_accounts
ADD CONSTRAINT uk_account_number UNIQUE (account_number);

ALTER TABLE bank_accounts
ADD CONSTRAINT uk_account_alias UNIQUE (alias);
```

## Consequences

### Positive

#### Para AccountNumber
- ✅ Identificadores no secuenciales (difíciles de enumerar) por el uso de `UUID.randomUUID()`
- ✅ Validación fuerte en el dominio gracias al VO `AccountNumber` (longitud y formato)
- ✅ El verificador permite detectar errores comunes (digitación/transcripción) sin necesidad de consultar almacenamiento
- ✅ Cumple estándar bancario argentino con algoritmo Módulo 11 compatible con CBU/CVU
- ✅ Se mantiene la arquitectura hexagonal: el dominio depende del puerto, no de detalles de generación

#### Para AccountAlias
- ✅ Alias fáciles de leer y comunicar (mejor UX)
- ✅ El dominio mantiene invariantes con `AccountAlias` (validación centralizada)
- ✅ Uso de `SecureRandom` reduce riesgos de predictibilidad frente a generadores pseudoaleatorios simples
- ✅ Arquitectura limpia: la estrategia de generación vive en infraestructura detrás de un puerto
- ✅ Experiencia similar a billeteras digitales conocidas (MercadoPago, Brubank, Ualá)

#### Ambos
- ✅ Desacoplamiento: Interfaces `AccountNumberGenerator` y `AccountAliasGenerator` permiten cambiar implementación sin afectar dominio
- ✅ Testabilidad: Fácil crear mocks para pruebas unitarias
- ✅ Trazabilidad: Logs de reintentos facilitan auditoría

### Negative

#### Para AccountNumber
- ❌ La extracción "hex → dígitos" no es una distribución perfectamente uniforme (se reduce con % 10), aunque suficiente para propósitos de identificación interna
- ❌ Requiere contemplar colisiones como posibilidad teórica (muy baja), por lo que el sistema debe garantizar unicidad al persistir (constraint + reintento)
- ❌ Complejidad adicional: Algoritmo Módulo 11 requiere comprensión específica
- ❌ No reversible: No se puede obtener UUID original desde el número de cuenta

#### Para AccountAlias
- ❌ Existe posibilidad de colisiones (espacio finito: 1,440,000 combinaciones)
  - Con 1,000 usuarios: ~0.035% de colisión
  - Con 10,000 usuarios: ~3.4% de colisión
  - Con 50,000 usuarios: ~60% de colisión
- ❌ Consultas a BD: Verificación de unicidad añade latencia (~5-10ms por intento)
- ❌ `SecureRandom` es marginalmente más costoso que `Random`, aunque el costo es irrelevante para un generador invocado en operaciones de alta de cuenta
- ❌ Diccionarios fijos: Agregar palabras requiere despliegue de código
- ❌ Posibles fallos: Si `MAX_RETRIES` se agota, falla la creación de cuenta

#### Ambos
- ❌ Overhead de infraestructura: Requiere componentes adicionales y constraints en BD
- ❌ Migración de datos: Sistemas existentes necesitan estrategia de transición

## Alternatives Considered

### Para AccountNumber

**Alternativa 1: Secuencial + verificador**
```java
String accountNumber = String.format("%022d", sequence.getNextValue());
```
- ❌ Rechazada: Más simple, pero incrementa riesgo de enumeración y filtrado de volumen. Alta predictibilidad

**Alternativa 2: UUID directo**
```java
String accountNumber = UUID.randomUUID().toString();
```
- ❌ Rechazada: Excelente unicidad, pero rompe el requisito de "solo dígitos" y longitud fija

**Alternativa 3: CSPRNG puro + base10**
- ❌ Rechazada: Mejor uniformidad, pero más código; se priorizó simplicidad y legibilidad

### Para AccountAlias

**Alternativa 1: Alias secuencial**
```java
String alias = "user" + sequenceNumber;
```
- ❌ Rechazada: Fácil de colisionar y altamente enumerable

**Alternativa 2: UUID corto con Base58**
```java
String alias = Base58.encode(UUID.randomUUID().getMostSignificantBits());
```
- ❌ Rechazada: Muy poco "humano" y más difícil de comunicar

**Alternativa 3: Random en vez de SecureRandom**
- ❌ Rechazada: Más rápido, pero más predecible si un atacante observa suficiente salida; se prefirió `SecureRandom` para robustez

**Alternativa 4: Palabras aleatorias sin verificación**
- ❌ Rechazada: Alto riesgo de colisiones en producción

## Recommendations

1. **Monitorear colisiones de alias**: Implementar métricas de Prometheus/Micrometer
   ```java
   meterRegistry.counter("alias.generation.retries", "attempt", String.valueOf(attempts)).increment();
   ```

2. **Expandir diccionarios**: Aumentar a 100 adjetivos y 100 sustantivos cuando la base de usuarios supere 50,000

3. **Considerar generación asíncrona**: Pre-generar pool de alias válidos en background job

4. **Auditoría**: Registrar todos los números de cuenta y alias generados para compliance

5. **Caché de verificación**: Implementar Redis para consultas de existencia más rápidas
   ```java
   // Verificar primero en caché antes de BD
   if (redisCache.exists(aliasValue) || aliasRepository.existsByAlias(aliasValue)) {
       // Reintento...
   }
   ```

6. **Circuit breaker**: Proteger contra múltiples fallos consecutivos en generación

## Related
- ADR-001: Arquitectura Hexagonal y Value Objects
- Estándar CBU Argentina (BCRA Comunicación A 5315)
- RFC 4122: UUID Specification
- Algoritmo Módulo 11 para dígitos verificadores

