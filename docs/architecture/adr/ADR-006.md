# ADR-006: Secure Error Handling and Request Traceability Strategy

## Status
Accepted

## Context

Banking systems are high-value targets for attackers. Error messages in API responses can inadvertently leak sensitive information that aids reconnaissance:

| Information Type | Attack Enabled |
|------------------|----------------|
| SQL table/column names | SQL injection refinement |
| Internal file paths | Path traversal attacks |
| Stack traces with class names | Technology fingerprinting |
| User existence confirmation | Account enumeration |
| Business rule details | Logic exploitation |

Additionally, when production issues occur, support teams need to correlate user-reported errors with server-side logs without exposing internal details to users.

**Requirements:**
1. Never expose internal system details to clients in production
2. Maintain full debugging capability for developers via logs
3. Enable users to reference specific errors when contacting support
4. Support distributed tracing in microservices architecture
5. Differentiate behavior between development and production environments

## Decision

### 1. Correlation ID Pattern

Every request is assigned a unique identifier that flows through the entire request lifecycle.

**Implementation: `CorrelationIdFilter`**

```
Request arrives
     │
     ▼
┌─────────────────────────────────────────┐
│  CorrelationIdFilter                    │
│  @Order(HIGHEST_PRECEDENCE)             │
│                                         │
│  1. Check X-Correlation-ID header       │
│  2. If missing: UUID.randomUUID()       │
│  3. MDC.put("correlationId", id)        │
│  4. response.setHeader("X-Correlation-ID", id) │
└─────────────────────────────────────────┘
     │
     ▼
  All subsequent filters, controllers,
  services, repositories have access
  to correlationId via MDC
     │
     ▼
┌─────────────────────────────────────────┐
│  finally { MDC.remove("correlationId") }│
└─────────────────────────────────────────┘
```

**Key decisions:**
- Use `OncePerRequestFilter` to guarantee single execution
- `@Order(HIGHEST_PRECEDENCE)` ensures it runs before security filters
- Accept client-provided correlation IDs for distributed tracing
- Add to response headers so clients can capture it
- Clean MDC after request to prevent thread pool contamination

### 2. Environment-Aware Error Sanitization

The `GlobalExceptionHandler` applies different strategies based on environment:

**Production (`spring.profiles.active=prod`):**
```json
{
  "timestamp": "2024-02-10T10:30:45.123Z",
  "status": 404,
  "error": "Not Found",
  "message": "The requested resource was not found",
  "correlationId": "abc-123-def-456"
}
```

**Development (`spring.profiles.active=dev`):**
```json
{
  "timestamp": "2024-02-10T10:30:45.123Z",
  "status": 404,
  "error": "Not Found",
  "message": "Customer with ID 999 not found",
  "correlationId": "abc-123-def-456"
}
```

**Generic messages by exception type:**

| Exception | Production Message |
|-----------|-------------------|
| `ResourceNotFoundException` | "The requested resource was not found" |
| `ResourceAlreadyExistsException` | "The operation could not be completed due to a conflict" |
| `AuthenticationException` | "Authentication failed" |
| `AccessDeniedException` | "You do not have permission to perform this action" |
| `BusinessRuleException` | "The operation violates business rules" |
| `MethodArgumentNotValidException` | "The request contains invalid data: [field names only]" |
| `InfrastructureException` | "An unexpected error occurred. Please contact support with the correlation ID" |
| `Exception` (catch-all) | "An unexpected error occurred. Please contact support with the correlation ID" |

### 3. Structured Logging with Logback

**Development profile** - Human-readable format:
```
2024-02-10 10:30:45.123 [abc-123-def-456] WARN  CustomerService - Customer with ID 999 not found
```

**Production profile** - JSON format for log aggregators (ELK, CloudWatch, Datadog):
```json
{"timestamp":"2024-02-10T10:30:45.123+0000","correlationId":"abc-123-def-456","level":"WARN","logger":"CustomerService","message":"Customer with ID 999 not found"}
```

**Pattern configuration:**
```xml
<!-- Development -->
<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{correlationId:-NO-CORRELATION-ID}] %-5level %logger{36} - %msg%n</pattern>

<!-- Production -->
<pattern>{"timestamp":"%d{yyyy-MM-dd'T'HH:mm:ss.SSSZ}","correlationId":"%X{correlationId:-NO-ID}","level":"%-5level","logger":"%logger{36}","message":"%msg"}%n</pattern>
```

**Log levels by profile:**

| Logger | Development | Production |
|--------|-------------|------------|
| Root | INFO | WARN |
| `com.banking.system` | INFO | INFO |
| `org.hibernate.SQL` | DEBUG | WARN |

### 4. CORS Configuration for Correlation ID

To allow frontend applications to read the correlation ID:

```java
// Allow client to SEND correlation ID (for distributed tracing)
configuration.setAllowedHeaders(List.of(..., "X-Correlation-ID"));

// Allow client to READ correlation ID from response
configuration.setExposedHeaders(List.of("Authorization", "X-Correlation-ID"));
```

### 5. Security Filter Chain Order

```
1. CorrelationIdFilter     ← First: establishes request context
2. RateLimitFilter         ← Has access to correlation ID for logging
3. JwtAuthenticationFilter ← Auth failures logged with correlation ID
4. UsernamePasswordAuthenticationFilter
5. Controllers/Services    ← All logs include correlation ID
6. GlobalExceptionHandler  ← Errors logged with full context
```

## Consequences

### Positive

1. **Security hardening**: No information disclosure in production responses
2. **Debuggability**: Full context preserved in server logs via correlation ID
3. **User experience**: Users can reference specific errors with correlation ID
4. **Distributed tracing**: Client-provided correlation IDs enable cross-service tracing
5. **Operational readiness**: JSON logs integrate with standard observability stacks
6. **Developer experience**: Detailed errors in development speed up debugging
7. **Compliance**: Audit trail of errors with unique identifiers
8. **Consistency**: Centralized error handling ensures uniform API responses

### Negative

1. **Response payload overhead**: Correlation ID adds ~50 bytes per response
2. **Log volume**: Full error details logged even for expected errors (4xx)
3. **Configuration complexity**: Environment-specific behavior requires careful testing
4. **MDC thread safety**: Requires proper cleanup in async scenarios

### Mitigations

| Concern | Mitigation |
|---------|------------|
| Async/reactive MDC propagation | Use `MdcContextLifter` or `Hooks.enableAutomaticContextPropagation()` for WebFlux |
| Log volume | Configure log rotation and retention policies |
| Testing environments | Ensure test profile behaves like production for security testing |

## Implementation Files

```
src/main/java/com/banking/system/common/infraestructure/
├── filter/
│   └── CorrelationIdFilter.java          # Request tracing
└── exception/
    └── GlobalExceptionHandler.java        # Error sanitization

src/main/resources/
└── logback-spring.xml                     # Structured logging

src/main/java/com/banking/system/auth/infraestructure/config/
└── SecurityConfig.java                    # Filter chain + CORS
```

## References

- [OWASP Error Handling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html)
- [OWASP Information Disclosure](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/)
- [Spring Boot Logging](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging)
- [MDC (Mapped Diagnostic Context)](https://logback.qos.ch/manual/mdc.html)
- [OpenTelemetry Trace Context](https://www.w3.org/TR/trace-context/)